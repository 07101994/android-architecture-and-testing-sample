# Android MVP & Clean Architecture sample with Unit and Instrumentation tests

## BlogReader App

This sample app loads and displays blog posts in a list. By clicking a blog post, you are taken to a detail UI, which shows the entire blog post body and comments.

The app uses a [fake blogpost API](https://jsonplaceholder.typicode.com) to load the posts and comments. All data is cached locally, so no unneeded network requests are being made until the cache becomes invalid.

### Maintainability

The application has **almost 90% test coverage**, so adding / changing features is not scary at all. You can always run the tests after making changes, and if they pass, you can be pretty sure you didn't break anything vital.

![Ain't nobody got time for tests](https://i.imgflip.com/18ng7d.jpg)

Actually, there's **only about 10 test functions**, and the longest one only has **8 lines of code**. That's not so much, is it?

## MVP? Clean? SOLID?

By following [Model-View-Presenter](https://en.wikipedia.org/wiki/Model–view–presenter), [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) and [SOLID Principles](https://scotch.io/bar-talk/s-o-l-i-d-the-first-five-principles-of-object-oriented-design), this app becomes:
* Easy to test. Business rules can be easily tested without Android emulators / devices in milliseconds. And the UI tests are't that horrible to write either.
* Easy to maintain. Adding / modifying functionality is easy, and doesn't cause a regression bug hell as everything is separated and tested.
* Independent of external third-party libraries. *Cache* can easily be replaced with Realm, without modifying the main application logic. **The application simply doesn't care about what frameworks we're using.**
* Independent of UI. The UI can easily be changed without changing the existing business logic. This could be easily converted to a desktop or even a command line app.

Everything is nicely decoupled. The application isn't dependent on concrete implementation details. They are more like plugins, *and they actually depend on the application; not the other way around*.

## How to run

The project has two build variants:

<dl>
  <dt>mock</dt>
  <dd>Instead of loading real data, populates the blog list and comments from a static FakeBlogApi to make testing easy. Also contains all the tests.</dd>

  <dt>prod</dt>
  <dd>The "real" app that actually loads real blog and comment data from a real API. <strong>Does not contain tests, they are in the mock variant.</strong></dd>
</dl>

## Package structure

### com.codemate.blogreader.data

Blog API and Cache implementations. The Blog API is defined in a simple interface that has ```getPosts()``` and ```getComments(int postId)``` methods. The implementation is then automatically generated by the [Retrofit library](http://square.github.io/retrofit/).

### com.codemate.blogreader.domain

Contains *the business rules* (usecases) that are our applications main functionality. No Android or external dependencies here, just plain Java.

Also contains the *BlogPost* and *Comment* models and the *PostCache* and *CommentCache* interfaces that the **data layer implements** for *SharedPrefCache*.

### com.codemate.blogreader.presentation

All the Android-related UI stuff, such as `Activities` and `RecyclerAdapters`. Also just plain Java `Presenter` objects and `View` interfaces implemented by the `Activities`.
